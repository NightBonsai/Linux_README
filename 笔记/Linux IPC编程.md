# Linux_README

## 目录
[返回主目录](https://github.com/NightBonsai/Linux_README/blob/main/README.md)

## Linux IPC编程

### *Linux系统调用内核函数& API函数库调用函数*：
- **系統调用**：直接请求操作系统内核服务，执行代码效率更高；每种操作系统内核函数各不相同，具有局限性
- **API函数库调用**：封装在程序内的函数；调用兼容性、可移植性更好；调用开销更小；

### Linux指令：
- 终端指令一man 23... 指令名；查看AP|使用手册一Linux Programmer's Manual

      umask()：  设置权限掩码,默认0022 rwx421-- -rwxrwxrwx777
      perror()： 输出报错信息，头文件stdlio.h中
      open()：   打开文件
      close()：  关闭文件
      write()：  文件写入数据
      read()：   文件读取数据

- 获取读写数据大小: .

      strlen-针对纯文本文件：txt cpp h
      sizeof-针对二进制文件：zip mp4 mp3

- Linux char数组初始化: 

      memset()函数 或 bzero()函数

### *Linux进程*：
- **进程ID(PID)**：每个Linux进程都有一个唯一的数字标识符; 总是非负整数
- **进程控制块(PCB)**：进程存在的唯一标志; =代码段+数据段+堆栈段
- **init进程**：PID为1的进程，在自举过程结束时由内核调用，绝不会终止

- **孤儿进程**：父进程比子进程先执行结束，父进程将子进程交付系统进程管理
- **僵尸进程**：子进程比父进程先执行结束，子进程执行逻辑结束，但内存没有收回
- **解决方案**：父进程比子进程先执行结束，子进程是否结束应该给父进程反馈，父进程依据反馈判断是否结束

### *Linux进程编程*：
- pid_t getpid(void)：返回调用进程的进程ID
- pid_t fork(void)：返回：子进程中为0，父进程中为子进程ID，出错为-1;
- **原理**：fork开出子进程，子进程复制父进程代码，因此一次调用会有两次返回
- Linux进程代码框架：

      pid = fork()
      if(pid > 0) .
      {
        //父进程
        wait(x);	//为了避免出现孤儿进程，父进程再逻辑执行完以后使用wait(x)函数
        //等待子进程结束
      }
      else if(pid == 0)
      {
        //子进程
        exit(0);	//为了避免出现僵尸进程，子进程结束以后要调用exit函数
      }

### Linux设备&文件IO：
- DIR目录
- struct dirent目录信息结构体

      DIR* opendir(char *pathname);
      打开一个目录
      返回：成功，返回一个目录指针；失败，返回0

      struct dirent* readdir ( DIR *dirptr);
      访问目录中的文件
      返回一个指向dirent结构的指针,它包含指定目录中下一个连接的细节;
      没有更多连接时，返回NULL

### *Linux信号机制*：
- 用于实现进程间通信
- 进程可以生成信号、捕捉并响应信号或屏蔽信号
- 是Qt信号与槽机制的祖宗

- 信号分类：

      不可靠信号：1~31 若连续发送，信号会被忽略；但是发送一次休息一会再发送则信号有效
      可靠信号：34~64 无论如何发送，信号一定会被执行

- kill终端指令：

      Linux指令，用于发送信号
      Kill-几号信号 进程PID

- Linux信号两种写法：

      无参信号：
          signal函数≈Qt connect函数
			        函数signal(哪个信号，函数指针)：绑定信号和执行函数
          kill函数：发送信号给指定进程
              函数kill(接收信号的进程，哪个信号)

      带参信号：
          sigaction函数=Qt connect函数，需要sigaction结构体变量作为参数
          sigaction结构体：信号是否可携带参数状态位，处理函数，屏蔽信号集
          sigqueue函数：发送信号给指定进程，需要union sigval联合体变量作为参数
          union sigval联合体：信号携带的参数(现在只能为int)
          处理函数(自定义)：函参列表与sigaction结构体中存储处理函数的元素的函参列表要一致

- Linux信号屏蔽(防止进程接收到不相关信号直接结束)： 
如果一个进程正在运行，没有绑定任何信号和处理函数。当运行中进程收到一个不认识的信号不知道如何处理就会中断进程执行。这个时候我们就需要考虑增加信号屏蔽确保程序的健壮性

      定义信号集：sigset_t数据类型
      信号集初始化：sigemptyset函数
      信号集添加：sigaddset函数
      信号集删除：sigdelset函数
      添加全部信号：sigfillset函数
      信号集启动屏蔽：igprocmask函数

- Linux信号冲突：
情况1：
一个进程正在执行信号处理函数，还在执行没有结束，这个时候进程又收
到同种信号
第一次执行结束后，再执行第二次执行函数
情况2：
一个进程正在执行信号处理函数，还在执行没有结束，这个时候进程又收
到异种信号
第一次执行函数打断，执行异种函数处理，异种函数处理结束后，回到第
一次还没处理完的执行函数
但时间上存在问题
结论：异种信号打断是会造成逻辑、数据出错
口诀：异种打断，同种排队
解决方案：一个信号在处理的时候不要被其他信号打扰，所以在这个信号绑定
的时候设置黑名单

struct sigaction属性sa_ mask

信号从传递数据角度来审视信号技术，性价比很低
信号的最佳实践：做进程通知

	Linux管道机制：
		管道用于进程通信
特点：半双工通信

匿名管道(无名管道)：
只用在亲缘关系进程之间
1.创建管道：
pipe函数，需要file_ descriptor[2]数组作为参数，file_ descriptor[0]表示读(入)端，file_ descriptor[1]表示写(出)端
2.进行write read读入写出
3.删除对应端：close函数，父进程中close读(入)端，子进程中close写(出)端

命名管道(有名管道)：
不相关进程间交换数据，利用FIFO管道文件，进程通过访问FIFO文件进行数
据通信
1.创建命名文件：mkfifo函数
2.打开管道文件：open函数
3.进行write read读入写出

	Linux IPC-进程间通信：
		Linux ipcs终端指令：查看消息队列、共享内存段、信号量数组
Linux ipcrm -a终端指令：清除用户创建的所有消息队列、共享内存段、信号量数组

Linux消息队列：
msgget函数：创建消息队列
msgsnd函数：发送消息至消息队列，参数需要消息体结构体
msgbuf (mtype：消息类型，用于接收；mtext：消息数据)
msgrcv函数：接收消息从消息队列，参数需要消息体结构体
msgbuf (mtype：消息类型，用于接收；mtext：消息数据),
接收消息类型：同结构体msgbuf的mtype一致

			Linux消息队列传输结构体数据：
利用memcpy函数
存入：将结构体数据传输给msgbuf里的mtext char数组
取出：将msgbuf里的mtext char数组传输给结构体数据

		Linux共享内存：
IPC通信效率最高，由操作系统管理
一个进程创建，所有进程可连接，共享数据

shmget函数：创建共享内存
shmat函数：进程连接共享内存，返回共享内存指针
利用memcpy将数据考进共享内存中
利用memcpy将数据从共享内存中考出
拿出数据后，利用memset重置共享内存段数据
shmdt函数：进程和共享内存断开连接

Linux IPC消息队列、IPC共享内存：
结合使用，共享内存用于数据通信，消息队列用于消息传递

		Linux 进程信号量：
≈线程互斥量&线程信号量
信号量：解决多个进程同时访问一个内存区域导致的数据安全问题

semget函数：创建一个新的信号量或者取得一个现有信号量的键字
semop函数：改变信号量的键值
semctl函数：允许我们直接控制信号量的信息；
p操作：-1加锁；v操作：+1解锁

	Linux POSIX多线程技术：
进程是资源分配的基本单位，线程是CPU调度的基本单位
一切进程至少都有一个执行线程
新的执行线程会拥有自己的堆栈(有自己的局部变量)，但要与它的创建者共享全局量、文件描述符、信号处理器和当前的子目录状态.
		
		VS2019 POSIX线程使用：
链接线程函数库：右键项目->属性->链接器->命令行->键入"-pthread"->确认

线程优缺点：
优点：比创建新进程代价小；切换时间短；占用资源少
缺点：调试多线程程序比调试单线程程序困难
解决任务并发运行问题；但给每个客户端开线程，资源消耗巨大

		Linux线程编程：
			引入线程函数库:文件<pthread.h>
pthread_ create函数：
作用：创建一个新的线程;
函参列表：新线程标识符，一般为NULL，线程启动要执行的函数地址(≈ QThread run函数)，传给线程启动要执行的函数的参数

		Linux线程同步：
两个(或多个)线程同时执行时，经常需要访问到公共资源或代码的关键部分
防止多个线程同时访问公共资源导致的数据出错问题
在对公共资源进行访问操作前后进行开关锁操作来实现

线程信号量:
sem_t sem; 			//二进制线程信号量，只有0和1两个值
sem_init(&sem, 0, 1); 	//线程信号量初始化，初始化为1
sem_wait(&sem); 		//信号量值-1，“关锁"一阻塞函数
sem_post(&sem); 		//信号量值+1，“开锁”
线程互斥量:
pthread_mutex_t mutex; 			//线程互斥量锁对象
pthread_mutex_init(&mutex, NULL); 	//互斥量锁初始化
pthread_mutex_lock(&mutex); 		//互诉量关锁"—阻塞函数
pthread_mutex_unlock(&mutex); 	//互斥量开锁”
